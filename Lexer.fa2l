#include <iostream>
#include <string>
#include <stdexcept>
#include "tokens.hpp"
#include <optional>
#include "SimplLexer.hpp"
#include <unordered_map>

int SimplLexer::getNextChar() {
    if (pos < input.length()) {
        int ch = input[pos];
        pos++;

        return ch;
    } else {
        return EOF;
    }
}

void SimplLexer::ungetChar(int ch) {
    if (pos > 0 && pos <= input.length() && ch != EOF) {
        pos --;
    }
}

void SimplLexer::reportError(int ch) {
    throw std::runtime_error(std::string("Invalid character '")
            + static_cast<char>(ch) + "'");
}

/*!fa2lexer
    %option generate.tokens = true;

    %file "SimplDFA/EOF.jff" name "EOF";
    %file "SimplDFA/Number.jff" name "Number";
    %file "SimplDFA/Ident.jff" name "Ident";
    %file "SimplDFA/Addition.jff" name "Addition";
    %file "SimplDFA/Subtraction.jff" name "Subtraction";
    %file "SimplDFA/Multiplication.jff" name "Multiplication";
    %file "SimplDFA/Module.jff" name "Module";
    %file "SimplDFA/Equal_And_Assignment.jff" name "Equal_And_Assignment";
    %file "SimplDFA/GreaterThanOrEqualTo.jff" name "GreaterThanOrEqualTo";
    %file "SimplDFA/LessThanOrEqualTo.jff" name "LessThanOrEqualTo";
    %file "SimplDFA/NotEqual.jff" name "NotEqual";
    %file "SimplDFA/Delimiters.jff" name "Delimiters";
    %file "SimplDFA/Division_And_Comments.jff" name "Division_And_Comments";

    %token.descriptions {
        KwIf = "keyword if",
        KwElse = "keyword else",
        KwWhile = "keyword while",
        KwTrue = "keyword true",
        KwFalse = "keyword false",
        KwInt = "keyword int",
        KwBool = "keyword Bool",
        KwLet = "Keyword Let",
        KwFn = "Keyword Fn",
        kwAnd = "Keyword And",
        KwOr = "Keyword Or",
        KwNot = "Keyword Negation",
        KwRef = "Keyword Ref",
        KwReturn = "Keyword return",
        KwFor = "Keyword for",
        kwNot = "Keyword not",
        KwVoid = "Keyword void",
        KwTo = "Keyword to",
        KwStep = "Keyword Step"
    }

    %generate.state_enum(State);
*/

Token SimplLexer::getNextToken() {
    text.clear();

    /*!fa2lexer
     %generate.lexer (text);
     */
}

std::string SimplLexer::tokenToString(Token tk)
{
   /*!fa2lexer
   %generate.toString (tk);
   */
}

void SimplLexer::initKeywords() {
    keywords["if"] = Token::KwIf;
    keywords["else"] = Token::KwElse;
    keywords["while"] = Token::KwWhile;
    keywords["true"] = Token::KwTrue;
    keywords["false"] = Token::KwFalse;
    keywords["int"] = Token::KwInt;
    keywords["let"] = Token::KwLet;
    keywords["bool"] = Token::KwBool;
    keywords["fn"] = Token::KwFn;
    keywords["and"] = Token::kwAnd;
    keywords["or"] = Token::KwOr;
    keywords["not"] = Token::KwNot;
    keywords["ref"] = Token::KwRef;
    keywords["for"] = Token::KwFor;
    keywords["return"] = Token::KwReturn;
    keywords["void"] = Token::KwVoid;

}

std::optional<Token> SimplLexer :: keywordToken(const std::string& text) {
    auto Token = keywords.find(text);
    if (Token != keywords.end()) {
        return Token->second;
    }
    return std::nullopt;
}
